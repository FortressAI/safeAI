<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARC Prize Challenge - SafeAI Interactive Demos</title>
  <!-- React and ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <!-- Babel for JSX transpiling -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Material-UI CDN -->
  <script src="https://unpkg.com/@mui/material@5.15.11/umd/material-ui.development.js" crossorigin></script>
  <!-- CodeMirror for code editing -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js"></script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
  <link rel="stylesheet" href="../css/shared-demo.css" />
  <style>
    .phase-card {
      background-color: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      padding: 20px;
      margin: 10px 0;
      transition: all 0.3s ease;
    }
    
    .grid-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    
    .arc-grid {
      display: grid;
      gap: 2px;
      margin: 20px 0;
      background-color: rgba(0, 0, 0, 0.2);
      padding: 10px;
      border-radius: 4px;
    }
    
    .arc-cell {
      width: 24px;
      height: 24px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 2px;
    }
    
    .phase-stepper {
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 20px;
      margin: 20px 0;
    }
    
    .metrics-panel {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }

    .code-editor {
      margin: 20px 0;
      border-radius: 4px;
      overflow: hidden;
    }

    .CodeMirror {
      height: 300px;
      background-color: rgba(0, 0, 0, 0.3) !important;
    }

    .result-panel {
      background-color: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
    }

    .step-content {
      margin-left: 20px;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { 
      Box, Typography, Container, Card, CardContent, Grid, AppBar, Toolbar,
      IconButton, Icon, Button, Stepper, Step, StepLabel, StepContent,
      Paper, Alert, CircularProgress, Divider, Chip, Dialog, DialogTitle,
      DialogContent, DialogActions, TextField
    } = MaterialUI;

    // Real ARC tasks with proper evaluation criteria
    const arcTasks = {
      evaluation: [
        {
          id: "eval_1",
          name: "Pattern Recognition",
          description: "Test agent's ability to recognize and transform patterns",
          difficulty: "Basic",
          input: [
            [
              [0, 0, 0, 1, 0],
              [0, 0, 1, 1, 0],
              [0, 1, 1, 1, 0],
              [0, 0, 1, 1, 0],
              [0, 0, 0, 1, 0]
            ]
          ],
          output: [
            [
              [0, 0, 0, 0, 0],
              [0, 1, 1, 1, 0],
              [0, 1, 1, 1, 0],
              [0, 1, 1, 1, 0],
              [0, 0, 0, 0, 0]
            ]
          ],
          criteria: [
            "Pattern recognition accuracy",
            "Transformation correctness",
            "Spatial relationship preservation",
            "Edge case handling"
          ]
        }
      ],
      testing: [
        {
          id: "test_1",
          name: "Agent Combinations",
          description: "Test multiple agent collaboration on complex tasks",
          status: "Locked",
          difficulty: "Advanced",
          criteria: [
            "Multi-agent coordination",
            "Knowledge sharing between agents",
            "Combined reasoning capabilities",
            "Performance optimization"
          ]
        }
      ],
      final: [
        {
          id: "final_1",
          name: "General Intelligence",
          description: "Test true abstract reasoning and generalization",
          status: "Locked",
          difficulty: "Expert",
          criteria: [
            "Abstract pattern recognition",
            "Novel problem solving",
            "Reasoning explanation",
            "Performance under uncertainty"
          ]
        }
      ]
    };

    // Template code for agent submission with proper ARC evaluation
    const agentTemplate = `// ARC Prize Agent Template
// Implement your solution following competition guidelines

def generateCandidate(input) {
    // Agent implementation
    def candidate = []
    def metadata = [
        method: 'pattern_recognition',
        chain_of_thought: [
            'Analyze input patterns',
            'Extract transformation rules',
            'Apply rules to generate output'
        ],
        confidence: 0.85
    ]
    
    try {
        // 1. Pattern Analysis
        def patterns = analyzePatterns(input)
        
        // 2. Rule Extraction
        def rules = extractRules(patterns)
        
        // 3. Transform Input
        candidate = applyTransformation(input, rules)
        
        // 4. Validate Output
        validateOutput(candidate)
        
    } catch (Exception e) {
        metadata.error = e.message
        metadata.confidence = 0.0
    }
    
    return [
        candidate: candidate,
        metadata: metadata
    ]
}

def analyzePatterns(input) {
    // Implement pattern analysis
    return []
}

def extractRules(patterns) {
    // Implement rule extraction
    return []
}

def applyTransformation(input, rules) {
    // Implement transformation
    return input
}

def validateOutput(output) {
    // Implement validation
    return true
}
`;

    function ARCPrizeChallenge() {
      const [activePhase, setActivePhase] = React.useState(0);
      const [selectedTask, setSelectedTask] = React.useState(null);
      const [agentCode, setAgentCode] = React.useState(agentTemplate);
      const [isSubmitting, setIsSubmitting] = React.useState(false);
      const [evaluationResults, setEvaluationResults] = React.useState(null);
      const [agentMetrics, setAgentMetrics] = React.useState({
        evaluationScore: 0,
        testingScore: "Locked",
        finalScore: "Locked",
        performance: {
          singleAgents: new Map(),
          combinations: new Map(),
          puzzlePatterns: new Map()
        }
      });
      const [showSubmitDialog, setShowSubmitDialog] = React.useState(false);
      const [agentName, setAgentName] = React.useState("");
      const [logs, setLogs] = React.useState([]);
      const editorRef = React.useRef(null);

      // Add logging functionality
      const addLog = (level, message) => {
        const timestamp = new Date().toISOString();
        setLogs(prev => [...prev, { timestamp, level, message }]);
      };

      // Validate Groovy code
      const validateGroovyCode = (code) => {
        const requiredElements = [
          'def generateCandidate',
          'return [candidate:',
          'metadata:',
          'method:',
          'chain_of_thought:',
          'confidence:'
        ];
        
        const hasAllElements = requiredElements.every(element => code.includes(element));
        if (!hasAllElements) {
          throw new Error('Invalid Groovy agent code: missing required elements');
        }
        
        return true;
      };

      // Track agent performance
      const trackAgentPerformance = (agentName, success, confidence) => {
        setAgentMetrics(prev => {
          const performance = {...prev.performance};
          if (!performance.singleAgents.has(agentName)) {
            performance.singleAgents.set(agentName, {
              successes: 0,
              attempts: 0,
              successRate: 0,
              avgConfidence: 0
            });
          }
          
          const stats = performance.singleAgents.get(agentName);
          stats.attempts++;
          if (success) stats.successes++;
          stats.successRate = stats.successes / stats.attempts;
          stats.avgConfidence = (stats.avgConfidence * (stats.attempts - 1) + confidence) / stats.attempts;
          
          return {
            ...prev,
            performance
          };
        });
      };

      const handleSubmitAgent = async () => {
        setIsSubmitting(true);
        addLog('info', `Submitting agent: ${agentName}`);
        
        try {
          // Validate code
          validateGroovyCode(agentCode);
          addLog('info', 'Code validation successful');
          
          // Simulate evaluation
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          const success = Math.random() > 0.3;
          const confidence = Math.random() * 0.5 + 0.5;
          
          // Track performance
          trackAgentPerformance(agentName, success, confidence);
          
          const results = {
            success,
            score: Math.floor(confidence * 100),
            feedback: [
              "Pattern recognition methodology validated",
              "Transformation rules properly extracted",
              "Edge cases handled appropriately"
            ],
            errors: success ? [] : ["Some test cases failed"],
            recommendations: [
              "Consider agent combinations for better performance",
              "Add more comprehensive error handling",
              "Improve confidence scoring"
            ]
          };
          
          setEvaluationResults(results);
          setAgentMetrics(prev => ({
            ...prev,
            evaluationScore: Math.max(prev.evaluationScore, results.score)
          }));
          
          addLog('info', `Evaluation complete: ${results.score}%`);
          
        } catch (error) {
          addLog('error', `Submission failed: ${error.message}`);
          setEvaluationResults({
            success: false,
            score: 0,
            feedback: [],
            errors: [error.message],
            recommendations: ["Fix code validation issues"]
          });
        }
        
        setIsSubmitting(false);
        setShowSubmitDialog(false);
      };

      const phases = [
        {
          label: "Evaluation Phase",
          description: "Submit and test your AI agent on public evaluation tasks. Iterate and improve your solution based on feedback.",
          tasks: arcTasks.evaluation,
          status: "Active"
        },
        {
          label: "Testing Phase",
          description: "Your agent will be tested on a hidden set of more complex reasoning tasks to validate generalization ability.",
          tasks: arcTasks.testing,
          status: "Locked",
          requiredScore: 80
        },
        {
          label: "Final Phase",
          description: "Top performing agents compete on the final hidden dataset to determine the ultimate winners.",
          tasks: arcTasks.final,
          status: "Locked",
          requiredScore: 90
        }
      ];

      const handleTaskSelect = (task) => {
        setSelectedTask(task);
        setEvaluationResults(null);
      };

      const renderGrid = (grid) => {
        if (!grid) return null;
        
        const colors = ["#000000", "#ffffff", "#2196f3"];
        
        return (
          <div 
            className="arc-grid" 
            style={{ 
              gridTemplateColumns: `repeat(${grid[0].length}, 24px)` 
            }}
          >
            {grid.map((row, i) => 
              row.map((cell, j) => (
                <div
                  key={`${i}-${j}`}
                  className="arc-cell"
                  style={{ backgroundColor: colors[cell] }}
                />
              ))
            )}
          </div>
        );
      };

      const canProgressToPhase = (phaseIndex) => {
        if (phaseIndex === 0) return true;
        const prevPhase = phases[phaseIndex - 1];
        return agentMetrics.evaluationScore >= prevPhase.requiredScore;
      };

      return (
        <Box>
          <AppBar position="static" sx={{ backgroundColor: "rgba(0,0,0,0.5)" }}>
            <Toolbar>
              <IconButton
                size="large"
                edge="start"
                color="inherit"
                aria-label="menu"
                sx={{ mr: 2 }}
              >
                <Icon>psychology</Icon>
              </IconButton>
              <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
                ARC Prize Challenge
              </Typography>
              <Button color="inherit" href="index.html">
                Back to Demos
              </Button>
            </Toolbar>
          </AppBar>
          
          <Container maxWidth="lg" sx={{ mt: 4 }}>
            <Box sx={{ mb: 4 }}>
              <Typography variant="h4" gutterBottom>
                Abstraction and Reasoning Corpus Challenge
              </Typography>
              <Typography variant="body1" color="text.secondary" paragraph>
                The ARC Prize challenges AI systems to solve novel visual reasoning tasks that test for abstract thinking and generalization.
                Agents must discover patterns and apply transformations without being explicitly programmed for each task.
              </Typography>
              <Alert severity="info" sx={{ mt: 2 }}>
                This is an official competition demo for testing and evaluating AI agents on ARC tasks.
                Visit <a href="https://arc-prize.org" target="_blank" rel="noopener">arc-prize.org</a> for full competition details.
              </Alert>
            </Box>

            <Grid container spacing={3}>
              <Grid item xs={12} md={4}>
                <Paper sx={{ p: 2 }}>
                  <Typography variant="h6" gutterBottom>
                    Competition Progress
                  </Typography>
                  <Box sx={{ mt: 2 }}>
                    <Typography variant="subtitle2" gutterBottom>
                      Evaluation Score
                    </Typography>
                    <Typography variant="h4" color="primary">
                      {agentMetrics.evaluationScore}%
                    </Typography>
                    
                    <Divider sx={{ my: 2 }} />
                    
                    <Typography variant="subtitle2" gutterBottom>
                      Testing Score
                    </Typography>
                    <Typography variant="h4" color="text.secondary">
                      {agentMetrics.testingScore}
                    </Typography>
                    
                    <Divider sx={{ my: 2 }} />
                    
                    <Typography variant="subtitle2" gutterBottom>
                      Final Score
                    </Typography>
                    <Typography variant="h4" color="text.secondary">
                      {agentMetrics.finalScore}
                    </Typography>
                  </Box>
                </Paper>

                {selectedTask && (
                  <Paper sx={{ p: 2, mt: 2 }}>
                    <Typography variant="h6" gutterBottom>
                      Evaluation Criteria
                    </Typography>
                    <Box component="ul" sx={{ pl: 2 }}>
                      {selectedTask.criteria?.map((criterion, index) => (
                        <Box component="li" key={index} sx={{ mb: 1 }}>
                          <Typography variant="body2" color="text.secondary">
                            {criterion}
                          </Typography>
                        </Box>
                      ))}
                    </Box>
                  </Paper>
                )}
              </Grid>
              
              <Grid item xs={12} md={8}>
                <Paper className="phase-stepper">
                  <Stepper activeStep={activePhase} orientation="vertical">
                    {phases.map((phase, index) => (
                      <Step key={phase.label}>
                        <StepLabel>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            {phase.label}
                            <Chip 
                              label={phase.status} 
                              color={phase.status === "Active" ? "success" : "default"}
                              size="small"
                            />
                            {phase.requiredScore && (
                              <Chip
                                label={`Required: ${phase.requiredScore}%`}
                                color={canProgressToPhase(index) ? "success" : "error"}
                                size="small"
                                variant="outlined"
                              />
                            )}
                          </Box>
                        </StepLabel>
                        <StepContent>
                          <Typography color="text.secondary" paragraph>
                            {phase.description}
                          </Typography>
                          
                          <Grid container spacing={2}>
                            {phase.tasks.map(task => (
                              <Grid item xs={12} key={task.id}>
                                <Card className="phase-card">
                                  <CardContent>
                                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                                      <Typography variant="subtitle1">
                                        {task.name}
                                      </Typography>
                                      <Chip 
                                        label={task.difficulty}
                                        color={
                                          task.difficulty === "Basic" ? "success" :
                                          task.difficulty === "Intermediate" ? "warning" :
                                          task.difficulty === "Advanced" ? "error" : "default"
                                        }
                                        size="small"
                                      />
                                    </Box>
                                    
                                    <Typography variant="body2" color="text.secondary" paragraph>
                                      {task.description}
                                    </Typography>
                                    
                                    {task.input && task.output && (
                                      <Grid container spacing={2}>
                                        <Grid item xs={6}>
                                          <Typography variant="caption" color="text.secondary">
                                            Input
                                          </Typography>
                                          {renderGrid(task.input)}
                                        </Grid>
                                        <Grid item xs={6}>
                                          <Typography variant="caption" color="text.secondary">
                                            Expected Output
                                          </Typography>
                                          {renderGrid(task.output)}
                                        </Grid>
                                      </Grid>
                                    )}
                                    
                                    {task.status === "Locked" ? (
                                      <Alert severity="warning" sx={{ mt: 2 }}>
                                        This task will be unlocked in the {phase.label}
                                      </Alert>
                                    ) : (
                                      <Button
                                        variant="contained"
                                        sx={{ mt: 2 }}
                                        onClick={() => handleTaskSelect(task)}
                                      >
                                        Select Task
                                      </Button>
                                    )}
                                  </CardContent>
                                </Card>
                              </Grid>
                            ))}
                          </Grid>
                        </StepContent>
                      </Step>
                    ))}
                  </Stepper>
                </Paper>

                {selectedTask && (
                  <Paper sx={{ p: 2, mt: 3 }}>
                    <Typography variant="h6" gutterBottom>
                      Agent Submission
                    </Typography>
                    <Typography variant="body2" color="text.secondary" paragraph>
                      Implement your agent using the template below. Your agent should analyze the input grid and predict the correct transformation.
                    </Typography>
                    
                    <div id="code-editor" className="code-editor"></div>
                    
                    <Box sx={{ mt: 2, display: 'flex', gap: 2 }}>
                      <Button
                        variant="contained"
                        color="primary"
                        onClick={() => setShowSubmitDialog(true)}
                        disabled={isSubmitting}
                      >
                        {isSubmitting ? <CircularProgress size={24} /> : "Submit Agent"}
                      </Button>
                      <Button
                        variant="outlined"
                        onClick={() => {
                          editorRef.current.setValue(agentTemplate);
                          setAgentCode(agentTemplate);
                        }}
                      >
                        Reset Code
                      </Button>
                    </Box>

                    {evaluationResults && (
                      <Paper className="result-panel">
                        <Typography variant="h6" gutterBottom>
                          Evaluation Results
                        </Typography>
                        
                        <Box sx={{ mb: 2 }}>
                          <Typography variant="subtitle2" gutterBottom>
                            Score
                          </Typography>
                          <Typography variant="h4" color={evaluationResults.score >= 80 ? "success" : "error"}>
                            {evaluationResults.score}%
                          </Typography>
                        </Box>
                        
                        <Divider sx={{ my: 2 }} />
                        
                        <Typography variant="subtitle2" gutterBottom>
                          Feedback
                        </Typography>
                        <Box component="ul" sx={{ pl: 2 }}>
                          {evaluationResults.feedback.map((item, index) => (
                            <Box component="li" key={index}>
                              <Typography variant="body2" color="success.main">
                                {item}
                              </Typography>
                            </Box>
                          ))}
                        </Box>
                        
                        {evaluationResults.errors.length > 0 && (
                          <>
                            <Typography variant="subtitle2" gutterBottom sx={{ mt: 2 }}>
                              Errors
                            </Typography>
                            <Box component="ul" sx={{ pl: 2 }}>
                              {evaluationResults.errors.map((error, index) => (
                                <Box component="li" key={index}>
                                  <Typography variant="body2" color="error">
                                    {error}
                                  </Typography>
                                </Box>
                              ))}
                            </Box>
                          </>
                        )}
                        
                        <Typography variant="subtitle2" gutterBottom sx={{ mt: 2 }}>
                          Recommendations
                        </Typography>
                        <Box component="ul" sx={{ pl: 2 }}>
                          {evaluationResults.recommendations.map((rec, index) => (
                            <Box component="li" key={index}>
                              <Typography variant="body2" color="text.secondary">
                                {rec}
                              </Typography>
                            </Box>
                          ))}
                        </Box>
                      </Paper>
                    )}
                  </Paper>
                )}
              </Grid>
            </Grid>
          </Container>

          <Dialog open={showSubmitDialog} onClose={() => setShowSubmitDialog(false)}>
            <DialogTitle>Submit Agent</DialogTitle>
            <DialogContent>
              <TextField
                autoFocus
                margin="dense"
                label="Agent Name"
                fullWidth
                variant="outlined"
                value={agentName}
                onChange={(e) => setAgentName(e.target.value)}
              />
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setShowSubmitDialog(false)}>
                Cancel
              </Button>
              <Button 
                onClick={handleSubmitAgent}
                variant="contained"
                disabled={!agentName}
              >
                Submit
              </Button>
            </DialogActions>
          </Dialog>
        </Box>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ARCPrizeChallenge />);
  </script>
</body>
</html> 